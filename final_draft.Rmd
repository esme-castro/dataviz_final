---
title: "Final_Draft"
author: "Esme, Zach, & Mandi"
date: "2/21/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(edld652)
library(tidyverse)
library(janitor)
library(here)
library(rio)
library(ggtext)
library(ggiraph)
```

```{r load-data}
######## Load CLASS data, clean, & select columns ########################
class <- import(here("data", "Class20032019.xlsx")) %>% 
  janitor::clean_names() # CLASS Data Set

class <- class %>% 
  rename(fips = stfips,
         state_abbr = state) # make class data a fips to match grad_rates df, same with the state abbreviation.

class <- class %>% 
  select(1:3, 6, 18, 47)

######## Load grad_rates, clean, & select columns ##########################
grad_rates <- get_data("EDFacts_acgr_lea_2011_2019") %>% 
  janitor::clean_names() # graduation rates (and cohorts)

grad_rates <- grad_rates %>% 
  mutate(fips = readr::parse_number(fipst)) #rename fipst to fips

grad_rates <- grad_rates %>% 
  select(1:8, 10, 12:27, 30)

####### Merge CLASS with grad_rates df ######################################
class_grads <- left_join(grad_rates, class, by = "fips") # class df w/ grad rates&state

####### Load state_info, clean, & select columns ############################
state_info <- readr::read_csv("https://github.com/kjhealy/fips-codes/raw/master/state_fips_master.csv") #state data with fipst

state_info <- subset(state_info, select = c(1, 4, 6, 7, 9, 10))
# just want the columns with unrepeated information to class_grad that can be used later (example: regions and divisions)
state_info <- state_info %>% 
   mutate(state_name = tolower(state_name)) %>% 
    rename(state = state_name)


###### Merge class_grads with state_info data ##################################
data <- left_join(class_grads, state_info) # this has grad rates and state info
```

```{r fiscal-data}
fiscal10 <- get_data("NCES_CCD_fiscal_district_2010") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal11 <- get_data("NCES_CCD_fiscal_district_2011") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal12 <- get_data("NCES_CCD_fiscal_district_2012") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal13 <- get_data("NCES_CCD_fiscal_district_2013") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal14 <- get_data("NCES_CCD_fiscal_district_2014") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal15 <- get_data("NCES_CCD_fiscal_district_2015") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal16 <- get_data("NCES_CCD_fiscal_district_2016") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal17 <- get_data("NCES_CCD_fiscal_district_2017") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)

fiscal18 <- get_data("NCES_CCD_fiscal_district_2018") %>% 
  janitor::clean_names() %>% 
  select(leaid, fipst, stabbr, totalrev, tfedrev,
         tstrev, tlocrev, tcurinst, tcurssvc)
```








<!-- Working on fiscal data here -->
Did Daniel show you a way to get around these large file sizes? We need all years of that fiscal data in one df that can be joined to grad_rates (after we merge CLASS data too) to make our finaized df.
```{r fiscal-data}
fiscal10 <- get_data("NCES_CCD_fiscal_district_2010") %>% 
  janitor::clean_names() # Esme, this is JUST 2010 fiscal data. It is a huge data set... We still need to import and merge all of these together and then to other dataset... Didn't Dr. Anderson show you how to get around this??

## Zach, I see what you mean, I will email Anderson and ask if he recommends
## making it into parquet files before merging or not. Also if we need to
## expand our R memory when using the data.

fiscal11 <- get_data("NCES_CCD_fiscal_district_2011") %>% 
  janitor::clean_names()

fiscal_df <- get_fiscal_data()

arrow::write_parquet(fiscal_df, here::here("data", "fiscal_df.parquet"))


## using code below as reference for fiscal data, do not remove yet #####
# first read in the data
class <- import(here("data", "Class20032019.xlsx")) %>% 
  janitor::clean_names()

# write it out as a parquet file
arrow::write_parquet(class, here::here("data", "Class20032019.parquet"))

# read it in again
class2 <- arrow::read_parquet(here::here("data", "Class20032019.parquet"))
```


<!-- ignore below code chunk, this was trying to get geo data, use first code chunk above instead of final project data -->
################## Below is what I have tried to do to merge all data ###########
``` {r} 
class <- import(here("data", "Class20032019.xlsx")) %>% 
  janitor::clean_names() # CLASS Data Set
class <- class %>% 
  rename(fips = stfips,
         state_abbr = state) # make class data a fips that matches grad_rates df, same with the state abbreviation.
class <- class %>% 
  select(1:3, 6, 18, 47)

grad_rates <- get_data("EDFacts_acgr_lea_2011_2019") %>% 
  janitor::clean_names() # graduation rates (and cohorts)
grad_rates <- grad_rates %>% 
  mutate(fips = readr::parse_number(fipst)) #rename fipst to fips
grad_rates <- grad_rates %>% 
  select(1:8, 10, 12:27, 30)

# join grad_rates and CLASS
class_grads <- left_join(grad_rates, class, by = "fips") 
  # class df w/ grad rates_state
class_grads <- class_grads %>% 
  rename(state = stnam) # to match map df
class_grads <- class_grads %>% 
  mutate(state = tolower(state)) # to match maps df

# add state mapping data UNNEEdED IF WE CANNOT FIGURE THIS OUT
# maps <- map_data("state") %>% # ggplot2::map_data
  #select(1:5)

# state regions to maps df
state_info <- readr::read_csv("https://github.com/kjhealy/fips-codes/raw/master/state_fips_master.csv") #state data with fipst

state_info <- subset(state_info, select = c(1, 4, 6, 7, 9, 10))
# just want the columns with unrepeated information to class_grad that can be used later (example: regions and divisions)

state_info <- state_info %>% 
   mutate(state_name = tolower(state_name)) %>% 
    rename(state = state_name)

# maps <- left_join(state_info, maps, by = "state") # DO NOT NEED THIS IF WE CANNOT FIGURE OUT DF SIZE PROBLEM

#join state_data with class_grads
# this works, but the df is so large that you cannot view the df.

#class_grads.1 <- left_join(class_grads, maps, by = "state") 

# DO NOT NEED THIS IF WE CANNOT FIGURE OUT GEO DATA FRAME SIZE ISSUE
# if this is simply too large, we may have to try and work by creating plots using two separate dataframes? class_grads and state_data
```

```{r}
# FULL DATA FRAME without geographic info. Therefore, if using this, we will not be able to make maps of data viz
df <- left_join(class_grads, state_info, by = "state") 
```


################################# ZACHS VIZ #############################################

```{r}
data.z <- data %>%
  separate(all_rate, c("lower", "upper"), sep = "-") %>% 
  filter(!grepl("G|L|P", lower)) %>%
  mutate(
    upper = ifelse(is.na(upper), lower, upper),
    lower = as.numeric(lower),
    upper = as.numeric(upper)
  ) %>% 
  rowwise() %>% 
  mutate(mean_rate = mean(c(lower, upper))) %>% 
  ungroup()
data.z <- data.z %>% 
  select(1:3, 25:32, 34:38)

data.z1 <- data.z %>% 
  group_by(stnam) %>% 
  summarize(state_avg = mean(mean_rate), # Collapse mean_rate by state to get only 1 mean value of grad rate for each state
            se = sd(mean_rate)/sqrt(n()))# get standard error of each state graduation average
data.z1$national_avg <- data.z1 %>% 
  summarize(national = mean(state_avg))

data.z1$se_national <- data.z1 %>% 
  summarize(se_national = sd(state_avg)/sqrt(n()))
```

```{r zviz-v1}
data.z1 %>% 
  mutate(stnam = fct_reorder(stnam, state_avg)) %>% 
  ggplot(aes(state_avg, stnam)) +
  geom_linerange(aes(xmin = state_avg - 1.96 * se,
                     xmax = state_avg + 1.96 * se),
                 color = "grey40") +
  geom_point() +
  theme_minimal()# shows state overall graduation rate with SE by state. . . 
```

```{r zviz-v2}
# FIND A WAY TO ADD THE NATIONAL AVG AND NATIONAL SD AS A NEW ROW SO IT CAN BE PLOTTED AS A REFERENCE; then use gghighlight to highlight the national average, highlight those above, highlight those below.
#Two Options (OR DO BOTH!!!!!)
# 1 - Add regions data (already done with z1.regions) and color based on regions
regions_only <- data.z %>% 
  select(4, 14, 15) %>% 
  unique()
z1.regions <- left_join(data.z1, regions_only, by = "stnam")

z1.regions %>% 
  mutate(stnam = fct_reorder(stnam, state_avg)) %>% 
  ggplot(aes(state_avg, stnam, color = region_name)) +
  geom_linerange(aes(xmin = state_avg - 1.96 * se,
                     xmax = state_avg + 1.96 * se),
                 color = "grey40") +
  geom_point() +
   geom_vline(xintercept = 78.17352,
             color = "darkslateblue",
             linetype = "solid",
             size = 0.8) +
  theme_minimal() +
  labs(x = "Graduation Rate (%) - 2011",
       y = "",
       title = "State Graduation Rates",
       subtitle = "By Region",
       caption = "Vertical blue line indicates the graduation rate of the United States",
       color = "Region") 

# 2 - If I can find a way to compress class df to just one value of timehs per state (year 2011, since the grad_rate data is just 2011), I can add a shape aesthetic so that each state then has a color for region and a shape for what category of class$timehs2. Of course, we would still have the national average highlighted, would have names of states that fall below national average in once color, those that fall above in another color. 
# Want to move the legends to the top left of inside the plot itself. 
# add descriptive title, subtitle, legend name, x and y labs, caption for data source and notes about missing data.
# ideally, color code the subtitle to with region names corresponding to colors in legend
# remove the midpoint vertical lines, just leave major gridlines

```

```{r zviz-final-data}
class.z <- class %>% 
  group_by(year, state_abbr) %>% 
  summarize(avg_timehs2 = mean(timehs2)
)
#writexl::write_xlsx(class.z, here("data", "class.z.xlsx"))
class.z.2010 <- import(here("data", "class.z.2010.xlsx"))

class.z.2010 <- left_join(z1.regions, class.z.2010)
```

```{r zviz-final-plot}
class.z.2010$avg_timehs2 = as.factor(class.z.2010$avg_timehs2)

class.z.2010 %>% 
  mutate(stnam = fct_reorder(stnam, state_avg)) %>% 
  ggplot(aes(state_avg, stnam, color = region_name, shape = avg_timehs2)) +
  geom_linerange(aes(xmin = state_avg - 1.96 * se,
                     xmax = state_avg + 1.96 * se),
                 color = "grey40") +
  geom_point(size = 3) +
  theme_minimal() +
  geom_vline(xintercept = 78.17352,
             color = "darkslateblue",
             linetype = "solid",
             size = 0.8) +
  geom_vline(xintercept = 76.14586,
             color = "red",
             linetype = "dashed",
             size = 0.5) +
  geom_vline(xintercept = 80.17532,
             color = "red",
             linetype = "dashed",
             size = 0.5) +
  coord_cartesian(xlim = c(60, 90)) +
  geom_text(aes(x = 79, y = 42,
                label = "National Average (78.2)"),
                size = 3,
                color = "darkslateblue",
                angle = 270, vjust = 1.2) +
  geom_text(aes(x = 75.5, y = 42,
                label = "Lower Limit (76.2)"),
                size = 3,
                color = "red",
                angle = 90, vjust = 1.2) +
  geom_text(aes(x = 81, y = 42,
                label = "Upper Limit (80.2)"),
                size = 3,
                color = "red",
                angle = 270, vjust = 1.2) + 
  theme(panel.grid.major.y = element_blank(), 
        panel.grid.major.x = element_line(color = "gray85"), 
        axis.title.x = element_text(face = "bold", size = 12),
        plot.title = element_text(hjust = .0, size = 14, face = "bold"), 
        plot.subtitle = element_text(hjust = -.16), 
        plot.caption = element_text(hjust = .5, size = 10, face = "italic"),
        legend.title = element_text(size = 10, face = "bold")) +
  labs(x = "Graduation Rate (%) - 2011",
       y = "",
       title = "State Graduation Rates",
       subtitle = "By Region and High School Physical Education Policy",
       caption = "DATA NOTE, INSERT NOTE THAT SOME STATES 
       WERE OMITTED DUE TO MISSING DATA (LIST THOSE STATES",
       color = "Region",
       shape = "HS PE Policy") +
  scale_shape_discrete(labels = 
                         c("0" = "No Requirement or Recommendation",
                           "2" = "90 min/wk Minimum",
                           "3" = "90 - 150 min/wk",
                           "4" = "150 - 225 min/wk",
                           "5" = "Requires 225 min/wk")) +
  guides(color = guide_legend(order = 1),
         shape = guide_legend(order = 2))
### Would like to find a way to make this plot include the states that are missing a value for either region or HS PE Policy that are denoted (all black if NA for region; an X if NA for HS PE Policy)
```


__Would be cool to have a separate plot from all of this data that just shows something like college drop-out rate by state, or something to show that although some states have high high school graduation rates, they may not be indicative of content learned and/or success after high school __

__MY MESS AROUND PLOTS__ 


Simple Interactive Plot for Testing
```{r}
gg_point = ggplot(data = class.z.2010) +
  geom_point_interactive(aes(x = state_avg, stnam, 
                             color = region_name,
                             shape = avg_timehs2,
                             tooltip = stnam, data_id = stnam))

z <- girafe(ggobj = gg_point)
if(interactive() ) print(z)
```



The following code chunk is incomplete. Ideally, this would be the final cleaned plot. Having trouble getting the interactivity to work with the aspect ratio. Would likely get rid of state labels on y-axis ... OR get rid of one of the legends and let the interactive component tell what each point corresponds to (e.g., region or HS PE time)

Would like to find a way to make this plot include the states that are missing a value for either region or HS PE Policy that are denoted (all black if NA for region; an X if NA for HS PE Policy)
```{r}
gg_point1 = class.z.2010 %>%  #THIS WORKS BUT DATA GETS PUSHED OFF AND CROWDED
  mutate(stnam = fct_reorder(stnam, state_avg)) %>% 
  ggplot(aes(state_avg, stnam, color = region_name, shape = avg_timehs2)) +
  geom_linerange(aes(xmin = state_avg - 1.96 * se,
                     xmax = state_avg + 1.96 * se),
                 color = "grey40") +
  geom_point_interactive(aes(x = state_avg, stnam, 
                             color = region_name,
                             shape = avg_timehs2,
                             tooltip = stnam, data_id = stnam)) +
  theme_minimal() +
  geom_vline(xintercept = 78.17352,
             color = "darkslateblue",
             linetype = "solid",
             size = 0.8) +
  geom_vline(xintercept = 76.14586,
             color = "red",
             linetype = "dashed",
             size = 0.5) +
  geom_vline(xintercept = 80.17532,
             color = "red",
             linetype = "dashed",
             size = 0.5) +
  coord_cartesian(xlim = c(60, 90)) +
  geom_text(aes(x = 79, y = 42,
                label = "National Average (78.2)"),
                size = 3,
                color = "darkslateblue",
                angle = 270, vjust = 1.2) +
  geom_text(aes(x = 75.5, y = 42,
                label = "Lower Limit (76.2)"),
                size = 3,
                color = "red",
                angle = 90, vjust = 1.2) +
  geom_text(aes(x = 81, y = 42,
                label = "Upper Limit (80.2)"),
                size = 3,
                color = "red",
                angle = 270, vjust = 1.2) + 
  theme(panel.grid.major.y = element_blank(), 
        panel.grid.major.x = element_line(color = "gray85"), 
        axis.title.x = element_text(face = "bold", size = 12),
        plot.title = element_text(hjust = .0, size = 14, face = "bold"), 
        plot.subtitle = element_text(hjust = -.16), 
        plot.caption = element_text(hjust = .5, size = 10, face = "italic"),
        legend.title = element_text(size = 10, face = "bold")) +
  labs(x = "Graduation Rate (%) - 2011",
       y = "",
       title = "State Graduation Rates",
       subtitle = "By Region and High School Physical Education Policy",
       caption = "DATA NOTE, INSERT NOTE THAT SOME STATES 
       WERE OMITTED DUE TO MISSING DATA (LIST THOSE STATES",
       color = "Region",
       shape = "HS PE Policy") +
  scale_shape_discrete(labels = 
                         c("0" = "No Requirement or Recommendation",
                           "2" = "90 min/wk Minimum",
                           "3" = "90 - 150 min/wk",
                           "4" = "150 - 225 min/wk",
                           "5" = "Requires 225 min/wk")) +
  guides(color = guide_legend(order = 1),
         shape = guide_legend(order = 2))

z.1 <- girafe(ggobj = gg_point1)
if(interactive() ) print(z.1) # How can I make this work. The animation and all components are included, but the plot is smashed together and crowded. 
```


####################### End of Zach Viz #####################